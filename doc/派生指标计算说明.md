# 派生指标计算说明



### 1. 相关名词解释说明

- 数据明细宽表：是对输入的明细数据进行一个抽象、映射和定义。数据明细宽表类似数据库中的表，有名称和多个字段。一般输入的都是JSON字符串。

- 宽表字段：是数据明细宽表中的字段，分为普通字段和时间字段。包含了对字段的名称、数据类型的定义以及注释。宽表字段一般都是标量。

- 宽表字段数据类型：分为整数（LONG）、小数（DOUBLE）、布尔（BOOLEAN）、字符串（STRING）。

- 时间字段：数据明细宽表中某个字段或者多个字段的业务语义是时间，可以标识其为时间字段且定义时间格式（TIMESTAMP、yyyy-MM-dd HH:mm:ss等）。数据明细宽表必须定义时间字段，且时间字段可以定义多个。

- 前置过滤条件：对输入的数据进行过滤，类似SQL语句中的WHERE语句。一段字符串（本质上是Aviator表达式），输入数据是明细数据，返回值是Boolean。前置过滤条件表达式可以由宽表中的任意字段进行组合编写表达式，返回Boolean即可。

- 维度字段：将维度进行抽取出来，统一进行管理。分为字典维度（可枚举）和业务维度。

- 绑定维度：类似于SQL中的GROUP BY分组字段，可以定义多个分组字段，将宽表字段和维度字段进行绑定。

- 窗口切分：数据是源源不断的，常用各种方式将数据分桶。常用窗口切分方式有时间窗口（滚动时间和滑动时间）、计数窗口、状态窗口、会话窗口、事件窗口、全窗口。

- 时间聚合粒度：选择数据明细宽表中定义的时间字段，同时定义时间聚合单位（毫秒、秒、分、时、天、周、月、季度、年）和长度。

- 状态条件：对于状态窗口而言，需要有字段标识状态是否发生改变，当状态字段的值发生改变时，划分成另外一个窗口。

- 聚合函数：数值型（SUM、AVG、MAX等）、对象型（MAXOBJECT等）、集合型（DISTINCTLIST）、映射型（BASEMAP）、混合型（BASEMIX）。

- 聚合函数计算参数：不同的聚合计算逻辑需要不同的计算参数。例如数值型需要计算结果为数值的表达式，集合型（去重列表、排序列表）需要去重字段、排序字段等。

  

### 2. 计算过程解释

#### 2.1 业务场景

A账号给B账号转账，有转出账号（account_no_out）、转入账号（account_no_in）、转账金额（amount）和时间戳字段（trans_timestamp），形成交易流水数据（trade_detail）。

计算指标：转入账号一天（自然天）中的交易金额大于1的累计转入金额。

#### 2.2 配置数据

计算派生指标的所有配置数据（数据明细宽表、维度、派生指标）

- 定义数据明细宽表（trade_detail）（转账交易流水明细表）
  - 配置宽表字段
    - account_no_out：转出账号，STRING类型
    - account_no_in：转入账号，STRING类型
    - amount：转账金额，DOUBLE类型
    - trans_timestamp：交易时间戳，字符串，毫秒值
  - 定义时间字段
    - trans_timestamp：标识为时间字段，选择时间格式为时间戳
- 定义维度
  - 维度字段
    - 账号：account_no，业务维度
- 绑定维度
  - 宽表字段：account_no_in：转入账号
  - 维度字段：account_no，业务维度
  - 二者进行绑定
- 派生指标配置数据
  - 选择数据明细宽表（trade_detail）
  - 选择时间字段（trans_timestamp）：选择上一步宽表中的时间字段（trans_timestamp）
  - 定义绑定维度：account_no_in宽表字段和account_no业务维度进行维度绑定
  - 定义聚合维度（account_no）：上一步就是在定义聚合维度
  - 定义前置过滤条件（amount > 1）：类似于SQL语句中的WHERE过滤条件
  - 定义时间聚合粒度（1和DAY）：选择时间长度和时间单位
  - 定义聚合函数和聚合函数计算参数（SUM(amount)）：选择求和聚合函数SUM和度量值amount
  - 定义指标名称（one_day_sum_amount）
  - 定义指标数据类型（小数Double）

#### 2.3 计算流程

1. 先执行前置过滤条件，如果为true则往下执行，否则结束。
2. 根据配置的时间字段，将明细数据中的时间格式化成时间戳。
3. 根据配置的时间聚合粒度，判断数据在时间区间。然后对数据进行分桶处理。
4. 根据account_no进行分组。
5. 这里是滚动时间窗口（1和DAY），根据分组条件和窗口条件取出之前的聚合值。
6. 执行聚合函数SUM(amount)。将度量值累加到之前的聚合值中。
7. 将聚合值写回到外部存储中。
8. 输出数据。

#### 2.4 计算逻辑SQL化解释

```sql
SELECT
    account_no_in AS account_no, //account_no_in宽表字段, account_no维度字段，这个过程称为绑定维度
	SUM(amount) AS sum_amount //SUM聚合逻辑, amount就是计算表达式, one_day_sum_amount指标名称
FROM 
	trade_detail  //trade_detail 数据明细宽表
WHERE
	amount > 1 //前置过滤条件
AND
	trans_timestamp in BETWEEN '2022-02-03 00:00:00' AND '2022-02-03 23:59:59' 
				//基于时间字段和时间聚合粒度（DAY和1）得到时间区间
GROUP BY 
	account_no //分组字段，这里可以指定多维度
```



### 3. 聚合函数说明

聚合函数分为：数值型（Numeric）、对象型（Object）、集合型（Collection）、映射型（Map）和混合型（Mix）这五种类型。

| 聚合类型 | 配置数据                                       | 输出数据          | 说明             |
| :------: | :--------------------------------------------- | ----------------- | ---------------- |
|  数值型  | 计算结果为数值的表达式                         | 数值              |                  |
|  对象型  | 比较字段列表、保留字段和原始数据               | 对象（JSON对象）  |                  |
|  集合型  | 去重字段列表、排序字段列表、保留字段和原始数据 | 集合（List和Set） |                  |
|  映射型  | key生成字段，value配置聚合逻辑                 | 映射（Map）       |                  |
|  混合型  | 多个聚合逻辑和多个聚合逻辑的计算表达式         | -                 | 多个基本聚合类型 |

#### 3.1 数值型

- 最大值（MAX）: 计算指定数据集的最大值，如过去24小时最大交易金额 √
- 最小值（MIN）: 计算指定数据集的最小值，如过去 24 小时最小交易金额 √
- 求和（SUM）: 对指定数据集的对象进行累加，如金额求和 √
- 计数（COUNT）: 对指定数据集的记录条数进行计算，如交易次数 √
- 平均值（AVG）: 对指定数据集计算单笔平均值 √
- 递增（INCREASECOUNT）: 同一账号过去30天的交易序列中出现的递增次数 √
- 递减（DECREASECOUNT）: 同一账号过去30天的交易序列中出现的递减次数 √
- 最大连续递增（MAXINCREASECOUNT）: 同一账号过去30天的交易序列中出现的最大连续递增次数 √
- 最大连续递减（MAXDECREASECOUNT）: 同一账号过去30天的交易序列中出现的最大连续递减次数 √
- 最大连续次数（MAXCONTINUOUSCOUNT）: 交易金额最大连续次数 √
- 方差（VARS）: 同一账号过去30天的交易方差值 √
- 标准差（VARP）: 同一账号过去30天的交易标准差 √
- 协方差（COV）: 同一账号过去30天交易频率和交易金额的协方差 √
- 峰度系数: 用于衡量一组数据的尖峭程度，例如账户交易在某一日突增即可用峰度系数来剥量
- 三阶中心炬: 同一账号过去30天的交易三阶中心矩值
- 四阶中心炬: 同一账号过去30天的交易四阶中心矩值

#### 3.2 对象型

- 上一笔（LAST）: 获得上一条数据记录的某个维度，如上一笔交易金额 
- 最大对象（MAXOBJECT）: 同一账号过去30天的最大值交易明细（指定比较字段, 存储原始明细） √
- 最大字段（MAXFIELD）: 同一账号过去30天的交易最大金额的时间（指定比较字段, 存储指定字段） √
- 最小对象（MINOBJECT）: 同一账号过去30天的最小值交易明细（指定比较字段, 存储原始明细） √
- 最小字段（MINFIELD）: 同一账号过去30天的交易最小金额的时间（指定比较字段, 存储指定字段） √
- 占位对象（OCCUPIEDOBJECT）: 同一账号过去30天的首次交易明细（存储明细数据） √
- 占位字段（OCCUPIEDFIELD）: 同一账号过去30天的首次交易日期（存储指定字段） √
- 取代对象（REPLACEDOBJECT）: 同一账号过去30天的最近一次交易明细（存储明细数据） √
- 取代字段（REPLACEDFIELD）: 同一账号过去30天的最近一次交易日期（存储指定字段） √

#### 3.3 集合型

- 对象列表（LISTOBJECT）: 同一账号过去30天的交易明细列表（存储原始明细） √
- 字段列表（LISTFIELD）: 同一账号过去30天的交易金额列表（存储指定字段） √
- 去重对象列表（DISTINCTLISTOBJECT）: 同一账号过去30天的去重交易明细列表（按照指定字段去重, 存储原始细） √
- 去重字段列表（DISTINCTLISTFIELD）: 同一账号过去30天的去重交易地点列表（按照指定字段去重, 存储指定段） √
- 对象排序列表（SORTEDLIMITLISTOBJECT）: 同一账号过去30天的交易明细列表（按照指定字段排序，存储原始明细） √
- 字段排序列表（SORTEDLIMITLISTFIELD）: 同一账号过去30天的交易金额列表（按照指定字段排序，存储指定字段） √
- 去重计数（DISTINCTCOUNT）: 在计数的基础上，按照指定字段进行去重 √
- 滑动计数（COUNTWINDOW）: 同一账号过去30天中最近5笔交易的总金额 √

#### 3.4 映射型

- 基本映射（BASEMAP）: 同一账户过去30天所有交易账号的累计交易金额 √
- TOPN映射（SORTVALUEMAP）：同一账户过去30天所有交易账号的累计交易金额，按照交易金额排序，并且取top N ，输出的仍然是MAP（需要value能够进行比较） √
- TOPN主键（SORTVALUERETURNKEYMAP）：同一账户过去30天所有交易账号的累加金额的topN账号（需要value能够进行比较）  √
- TOPN值（SORTVALUERETURNVALUEMAP）：同一账户过去30天所有交易账号的累计金额的topN金额（需要value能够进行比较）  √

#### 3.5 混合型

- 基本混合型（BASEMIX）：一般是数值型聚合逻辑进行混合计算：例如SUM(IF(type = '信用卡', amount, 0)) / SUM(amount)。信用卡消费金额占总消费金额的比例 √

#### 3.6 CEP

- 复杂事件序列（事件模式）: 账户过去24小时修改密码1分钟内进行转入交易，后30秒进行转出交易的次数; √

#### 3.7 解释说明

1. 数值型、对象型、集合型这三种是基本聚合类型。
2. 各种聚合、排序、分组、比较和去重的字段都是表达式。类似SQL的IF(type = '张三', amount, 0)。
3. 排序可以进行多表达式进行排序，可以指定升序和降序。类似SQL的ORDER BY (age + 1) ACS, age DESC。
4. 去重可以进行多表达式去重。例如DISTINCT user_name, age（MySQL不支持多字段去重）
5. 限制长度的逻辑和SQL的LIMIT语义一致。
6. 映射类型的底层存储的是map，key是多字段去重列表，value类型是基本聚合类型。
7. 混合类型一般是只同类型的基本聚合类型进行表达式求值计算。
8. 滑动计数窗口和CEP需要额外聚合字段处理器，额外的聚合处理器都是基本聚合类型。



### 4. 基本字段处理器说明

#### 4.1 时间字段处理器（TimeFieldProcessor）

- 配置：时间字段（明细字段名（timeColumnName）和时间格式（timeFormat））
- 输入：明细数据（JSONObject）
- 输出：时间戳毫秒值（Long）

根据配置的时间字段（明细字段名和时间格式），从输入的明细数据中，提取出时间戳毫秒值。

#### 4.2 前置过滤条件字段处理器（FilterFieldProcessor）

- 配置：前置过滤条件（String，Aviator表达式）
- 输入：明细数据（JSONObject）
- 输出：true或者false

根据配置的前置过滤条件（Aviator表达式），输入明细数据，输出true或者false。

#### 4.3 维度字段处理器（DimensionSetProcessor）

- 配置：绑定维度数据（指标的key（明细宽表id_指标id）、name、List<Dimension>）
- 输入：明细数据（JSONObject）
- 输出：DimensionSet（维度类：指标的key（明细宽表id_指标id）、name、dimensionMap（k维度名，value具体的值））

根据配置的绑定维度，输入明细数据，输出维度数据（指标的key、name、dimensionMap），可以作为该指标的唯一标识。

#### 4.4 度量值字段处理器（MetricFieldProcessor）

- 配置：配置的Aviator表达式（String）
- 输入：明细数据（JSONObject）
- 输出：Object

根据配置的Aviator表达式，输入明细数据，得到计算结果。

#### 4.5 多字段去重字段处理器（MultiFieldDistinctFieldProcessor）

- 配置：去重表达式列表（List<String>）
- 输入：明细数据（JSONObject）
- 输出：多字段去重列表（MultiFieldDistinctKey，重写了hashCode和equals方法）

对于去重集合和去重计数，可以配置一个或者多个表达式去重。配置多个去重表达式，输入明细数据，得到列表用于去重。

#### 4.6 多字段排序字段处理器（MultiFieldOrderFieldProcessor）

- 配置：排序表达式列表（List<FieldOrderParam> FieldOrderParam指定字段表达式和升序还是降序 ）
- 输入：明细数据（JSONObject）
- 输出：多字段排序列表（MultiFieldOrderCompareKey，实现了Comparable接口，重写了compareTo方法）

对于排序列表、最大对象和最小对象，可以配置一个或者多个字段进行排序，可以指定升序和降序。配置多字段排序，输入明细数据，得到列表用于排序。

#### 4.7 多表达式字段处理器（MetricListFieldProcessor）

- 配置：List<配置的Aviator表达式（String）> ，多表达式列表
- 输入：明细数据（JSONObject）
- 输出：List<Object>



### 5. 聚合字段处理器和聚合函数计算参数说明

对于聚合类型的字段处理器输入的都是明细数据，输出的都是度量值。

#### 5.1 数值型、对象型和集合型（基本聚合类型）

- 数值型：通过表达式计算得到度量值，对度量值进行聚合运算。需要MetricFieldProcessor（计算得到度量值）。如果是多字段的，比如协方差。需要MetricListFieldProcessor（计算得到多个度量值）。

- 对象型：通过表达式计算得到比较字段（最大、最小对象），需要MultiFieldOrderFieldProcessor（比较字段）。如果值保留指定字段，需要MetricFieldProcessor（保留指定字段）
- 集合型：如果是多字段排序，需要MultiFieldOrderFieldProcessor（排序）。如果多字段去重，需要MultiFieldDistinctFieldProcessor（多字段去重）。如果保留指定字段，需要MetricFieldProcessor（保留字段）

BaseUdafParam（针对数值型、集合型、对象型）

```json
{
    //聚合类型
    "aggregateType": "SUM",
    //度量字段表达式(数值型)
    "metricExpress": "age + 1",
    //多字段度量字段表达式：数值型需要。例如协方差需要两个参数
    "metricExpressList": [
        "age + 1",
        "age + 2"
    ],
    //保留字段表达式(对象型、集合型只保留原始数据中的指定字段)
    "retainExpress": "account_no_in",
    //对象型比较字段列表(对象型最大对象、最小对象)
    "objectiveCompareFieldList": [
        "user_name",
        "age"
    ],
    //集合型排序字段列表(集合型(升序、降序))
	"collectiveSortFieldList": [
        {
            "express": "age + 1",
            "desc": true
        }
    ],
    //去重字段列表(集合型(去重计数、去重列表))
    "distinctFieldList": [
    	"user_name",
    	"age"
    ],
    //udaf函数中的参数
    "param": {
    	"limit": 10
	}
}
```

- 聚合类型（aggregateType）：页面上配置的聚合类型
- 度量字段表达式（metricExpress）：数值型需要，编写一个表达式，计算输出数值
- 多字段度量字段表达式（metricExpressList）：数值型需要，例如协方差需要两个参数
- 保留字段表达式（retainExpress）：对象型和集合型只保留指定字段的值
- 对象型比较字段列表（objectiveCompareFieldList）：对象型最大对象、最小对象按照多个字段进行比较
- 集合型排序字段列表（collectiveSortFieldList）：类似SQL中的ORDER BY id ASC, user_name DESC，多字段排序。对象型（最大对象、最小对象）、集合型（排序列表）
- 去重字段列表（distinctFieldList）：根据多个字段进行去重。集合型（去重列表、去重计数）
- udaf函数中的参数（param）：例如排序列表，指定limit参数，限制条数。key和Java聚合函数字段名称一致

#### 5.2 映射型（底层是Map）

   通过多字段去重字段处理器得到多字段去重列表（distinctFieldList）作为map的key，value是基本聚合类型（数值型、集合型和对象型）。

MapUnitUdafParam（映射类udaf参数）

```json
{
    //聚合类型
    "aggregateType": "BASEMAP",
    //key的表达式(去重字段列表)
    "distinctFieldList": [
    	"account_no_out"
    ],
    //BaseUdafParam, 聚合参数是数值型、集合型、对象型
    "valueAggParam": {
		...
    },
    //udaf函数中的参数
    "param": {
    	"limit": 10
	}
}
```

- 聚合类型（aggregateType）：页面上选择的聚合类型
- key的表达式（distinctFieldList）：去重字段列表，可以根据多个字段进行去重
- value的聚合函数参数（valueAggParam）：BaseUdafParam, 聚合参数是数值型、集合型、对象型
- udaf函数中的参数（param）：例如排序列表，指定limit参数，限制条数。key和Java聚合函数字段名称一致

#### 5.3 滑动计数窗口

一种特殊的集合型，需要额外聚合处理。需要BaseUdafParam baseUdafParam和BaseUdafParam externalBaseUdafParam

滑动计数窗口是一种特殊的集合类型，只是需要必传参数limit，复用BaseUdafParam即可

BaseUdafParam（滑动计数窗口udaf参数）

```json
{
    //聚合类型
    "aggregateType": "LISTOBJECTCOUNTWINDOW",
    //udaf函数中的参数
    "param": {
    	"limit": 10
	}
}
```

滑动计数窗口需要额外的聚合字段处理器（数值、对象、集合型）

BaseUdafParam externalBaseUdafParam，复用BaseUdafParam即可

#### 5.4 混合类型

有多个基本聚合类型处理器，然后进行表达式计算

MixUnitUdafParam	混合型udaf参数

```json
{
    //聚合类型
    "aggregateType": "BASEMIXUNIT",
    //mixAggMap。k是名字, value是基本聚合类型的参数(BaseUdafParam), 用于定义聚合计算逻辑
    "mixAggMap": {
        "上海_sum": {
            "aggregateType": "SUM",
      		"metricExpress": "city == '上海' ? amount : 0"
        },
        "全国_sum": {
          "aggregateType": "SUM",
          "metricExpress": "amount"
        }
    },
    //计算表达式
    "express": "上海_sum / 全国_sum",
    //udaf函数中的参数
    "param": {
    	"limit": 10
	}
}
```

- 聚合类型（aggregateType）：页面上选择的聚合类型
- 混合聚合类型定义（mixAggMap）：k是名字, value是基本聚合类型的参数（BaseUdafParam）, 用于定义聚合计算逻辑
- 计算表达式（express）：是多个聚合值的计算表达式
- udaf函数中的参数（param）：参数传递给unit

#### 5.5 CEP

需要额外聚合处理器（输出的数据就是List<JSONObject>，进行二次聚合）



- 额外聚合字段处理器：与子聚合字段处理器的却别在于聚合输出的数据是一个List<JSONObject>，然后进行额外的聚合
- 混合字段处理器：



### 6. 聚合函数说明

```java
/**
 * 定义输入数据、中间状态累计数据、输出数据
 * <p>该函数定义了如何进行增量计算，是一个无状态函数</p>
 * <p>需要空参构造方法，用于反射生成</p>
 * <p>聚合函数的相关参数，会在反射调用空参构造方法生成聚合函数对象后，反射给聚合函数的参数赋值</p>
 *
 * @param <IN> 输入的数据
 * @param <ACC> 中间累加数据 需要有空参构造方法，可以进行序列化和反序列化
 * @param <OUT> 输出的数据
 */
public interface AggregateFunction<IN, ACC, OUT> {

    /**
     * 初始化方法, 默认空代码, 实现类可以重写该方法
     * <p>给反射生成聚合函数，且给聚合函数的参数赋值完成后，会调用init方法</p>
     */
    default void init() {
    }

    /**
     * Creates a new accumulator, starting a new aggregate.
     *
     * <p>The new accumulator is typically meaningless unless a value is added via {@link
     * #add(IN, ACC)}.
     *
     * <p>The accumulator is the state of a running aggregation. When a program has multiple
     * aggregates in progress (such as per key and window), the state (per key and window) is the
     * size of the accumulator.
     *
     * @return A new accumulator, corresponding to an empty aggregate.
     */
    ACC createAccumulator();

    /**
     * Adds the given input into the given accumulator, returning the new accumulator input.
     *
     * <p>For efficiency, the input accumulator may be modified and returned.
     *
     * @param input The input to add
     * @param accumulator The accumulator to add the input to
     * @return The accumulator with the updated state
     */
    ACC add(IN input, ACC accumulator);

    /**
     * Gets the result of the aggregation from the accumulator.
     *
     * @param accumulator The accumulator of the aggregation
     * @return The final aggregation result.
     */
    OUT getResult(ACC accumulator);

    /**
     * Merges two accumulators, returning an accumulator with the merged state.
     *
     * <p>This function may reuse any of the given accumulators as the target for the merge and
     * return that. The assumption is that the given accumulators will not be used any more after
     * having been passed to this function.
     *
     * @param thisAccumulator An accumulator to merge
     * @param thatAccumulator Another accumulator to merge
     * @return The accumulator with the merged state
     */
    ACC merge(ACC thisAccumulator, ACC thatAccumulator);

}
```



### 7. 窗口说明

将数据进行切分，然后一定规则划分到不同的桶中去，常见的有时间窗口（TimeWindow）、状态窗口（StatusWindow）、计数窗口（CountWindow）、会话窗口（Session Window）、全窗口（Global Window）、事件窗口（EventWindow）等。

滚动时间窗口

滑动时间窗口

会话窗口

滑动计数窗口

状态窗口

事件窗口

全窗口



### 8. udaf函数管理

#### 8.1 udaf的Jar包管理

#### 8.2 udaf函数参数设计

- 有默认值
- 展示中文注释
- 需要明确数据类型，对输入的数据进行数据类型匹配
- 不可更改



### 9. kryo序列化和反序列化



### 10. 指标计算对外提供接口



### 11. 状态外部存储说明